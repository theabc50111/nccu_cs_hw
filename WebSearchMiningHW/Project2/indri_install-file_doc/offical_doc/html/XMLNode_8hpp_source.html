<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Indri: XMLNode.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_75b82e7e4a5feb05200b9ad7adf06257.html">home</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_e66345dc6d1b86d5ae575ef167b2f0e3.html">dfisher</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_bea7fe193197db75935da8b819262029.html">work1</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_dc42d2abfa4957ea59e562d7b055053d.html">indri</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_4eb84ac341285b465804c24c7ab136d3.html">include</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_2a13c2a5b681f3a69ef019f5e983f3bf.html">indri</a>
  </div>
</div>
<div class="contents">
<h1>XMLNode.hpp</h1><a href="XMLNode_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*==========================================================================</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (c) 2004 University of Massachusetts.  All Rights Reserved.</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Use of the Lemur Toolkit for Language Modeling and Information Retrieval</span>
<a name="l00005"></a>00005 <span class="comment"> * is subject to the terms of the software license set forth in the LICENSE</span>
<a name="l00006"></a>00006 <span class="comment"> * file included with this software, and also available at</span>
<a name="l00007"></a>00007 <span class="comment"> * http://www.lemurproject.org/license.html</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> *==========================================================================</span>
<a name="l00010"></a>00010 <span class="comment"> */</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="comment">//</span>
<a name="l00014"></a>00014 <span class="comment">// XMLNode</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// 8 October 2003 - tds</span>
<a name="l00017"></a>00017 <span class="comment">//</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#ifndef MONITOR_XMLNODE_H</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#define MONITOR_XMLNODE_H</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;map&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="indri-platform_8h.html">indri/indri-platform.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;lemur/lemur-compat.hpp&quot;</span>
<a name="l00032"></a>00032 <span class="keyword">namespace </span>indri
<a name="l00033"></a>00033 {
<a name="l00035"></a><a class="code" href="namespaceindri_1_1xml.html">00035</a>   <span class="keyword">namespace </span>xml
<a name="l00036"></a>00036   {
<a name="l00037"></a>00037     
<a name="l00040"></a><a class="code" href="classindri_1_1xml_1_1XMLNode.html">00040</a>     <span class="keyword">class </span><a class="code" href="classindri_1_1xml_1_1XMLNode.html">XMLNode</a> {
<a name="l00041"></a>00041     <span class="keyword">public</span>:
<a name="l00042"></a><a class="code" href="classindri_1_1xml_1_1XMLNode.html#a66eea11d0d7ba7d03205c27f13a996df">00042</a>       <span class="keyword">typedef</span> std::map&lt;std::string,std::string&gt; <a class="code" href="classindri_1_1xml_1_1XMLNode.html#a66eea11d0d7ba7d03205c27f13a996df">MAttributes</a>;
<a name="l00043"></a>00043   
<a name="l00044"></a>00044     <span class="keyword">private</span>:
<a name="l00045"></a><a class="code" href="classindri_1_1xml_1_1XMLNode.html#a317a29ec702be941d32a694ff351e78b">00045</a>       std::string <a class="code" href="classindri_1_1xml_1_1XMLNode.html#a317a29ec702be941d32a694ff351e78b">_name</a>;
<a name="l00046"></a><a class="code" href="classindri_1_1xml_1_1XMLNode.html#af77ab3e79559404a01b2ce87bd165067">00046</a>       <a class="code" href="classindri_1_1xml_1_1XMLNode.html#a66eea11d0d7ba7d03205c27f13a996df">MAttributes</a> <a class="code" href="classindri_1_1xml_1_1XMLNode.html#af77ab3e79559404a01b2ce87bd165067">_attributes</a>;
<a name="l00047"></a><a class="code" href="classindri_1_1xml_1_1XMLNode.html#ac867008c32f6b6771d8657cfbbe2265f">00047</a>       std::vector&lt;XMLNode*&gt; <a class="code" href="classindri_1_1xml_1_1XMLNode.html#ac867008c32f6b6771d8657cfbbe2265f">_children</a>;
<a name="l00048"></a><a class="code" href="classindri_1_1xml_1_1XMLNode.html#a6ef9f3a1f8936afe691d798ad884fa4d">00048</a>       std::string <a class="code" href="classindri_1_1xml_1_1XMLNode.html#a6ef9f3a1f8936afe691d798ad884fa4d">_value</a>;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050     <span class="keyword">public</span>:
<a name="l00053"></a>00053       <a class="code" href="classindri_1_1xml_1_1XMLNode.html#ac1b596a71b789270b9888198a7090673">XMLNode</a>( <span class="keyword">const</span> std::string&amp; name );
<a name="l00057"></a>00057       <a class="code" href="classindri_1_1xml_1_1XMLNode.html#ac1b596a71b789270b9888198a7090673">XMLNode</a>( <span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string&amp; value );
<a name="l00061"></a>00061       <a class="code" href="classindri_1_1xml_1_1XMLNode.html#ac1b596a71b789270b9888198a7090673">XMLNode</a>( <span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <a class="code" href="classindri_1_1xml_1_1XMLNode.html#a66eea11d0d7ba7d03205c27f13a996df">MAttributes</a>&amp; attributes );
<a name="l00066"></a>00066       <a class="code" href="classindri_1_1xml_1_1XMLNode.html#ac1b596a71b789270b9888198a7090673">XMLNode</a>( <span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> <a class="code" href="classindri_1_1xml_1_1XMLNode.html#a66eea11d0d7ba7d03205c27f13a996df">MAttributes</a>&amp; attributes, <span class="keyword">const</span> std::string&amp; value );
<a name="l00068"></a>00068       <a class="code" href="classindri_1_1xml_1_1XMLNode.html#a2fe2653158135a91fe70bd5b2a835026" title="clean up">~XMLNode</a>();
<a name="l00071"></a>00071       <span class="keywordtype">void</span> <a class="code" href="classindri_1_1xml_1_1XMLNode.html#a475af8cb2b4e8130f469b7ca2cf74293">addChild</a>( <a class="code" href="classindri_1_1xml_1_1XMLNode.html">XMLNode</a>* child );
<a name="l00075"></a>00075       <span class="keywordtype">void</span> <a class="code" href="classindri_1_1xml_1_1XMLNode.html#a4b08d38ed7308e7bad10c0b9ed220706">addAttribute</a>( <span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> std::string&amp; value );
<a name="l00078"></a>00078       <span class="keywordtype">void</span> <a class="code" href="classindri_1_1xml_1_1XMLNode.html#a670048df1fe72070b4f2c834a094d81f">setValue</a>( <span class="keyword">const</span> std::string&amp; value );
<a name="l00080"></a>00080       <span class="keyword">const</span> std::string&amp; <a class="code" href="classindri_1_1xml_1_1XMLNode.html#aa320a1b3eb64ae7246681dc78d37f341">getName</a>() <span class="keyword">const</span>;
<a name="l00082"></a>00082       <span class="keyword">const</span> std::string&amp; <a class="code" href="classindri_1_1xml_1_1XMLNode.html#a69ba6447d5954f6abbaa4562e2a5b3bc">getValue</a>() <span class="keyword">const</span>;
<a name="l00084"></a>00084       <span class="keyword">const</span> <a class="code" href="classindri_1_1xml_1_1XMLNode.html#a66eea11d0d7ba7d03205c27f13a996df">MAttributes</a>&amp; <a class="code" href="classindri_1_1xml_1_1XMLNode.html#a84859adfa8c8bc6ebd0899468b591ecc">getAttributes</a>() <span class="keyword">const</span>;
<a name="l00088"></a>00088       std::string <a class="code" href="classindri_1_1xml_1_1XMLNode.html#ad862c42bbf3358064096b8a56f1e79d0">getAttribute</a>( <span class="keyword">const</span> std::string&amp; name ) <span class="keyword">const</span>;
<a name="l00091"></a>00091       <span class="keyword">const</span> std::vector&lt;XMLNode*&gt;&amp; <a class="code" href="classindri_1_1xml_1_1XMLNode.html#ac2595953968b2ed188c02b6e86a64007">getChildren</a>() <span class="keyword">const</span>;
<a name="l00095"></a>00095       <span class="keyword">const</span> <a class="code" href="classindri_1_1xml_1_1XMLNode.html">XMLNode</a>* <a class="code" href="classindri_1_1xml_1_1XMLNode.html#a34eb7bb6d5793bf48583d3b348f40018">getChild</a>( <span class="keyword">const</span> std::string&amp; name ) <span class="keyword">const</span>;  
<a name="l00099"></a>00099       std::string <a class="code" href="classindri_1_1xml_1_1XMLNode.html#aac6729015e9602265fb9eff1b3c42036">getChildValue</a>( <span class="keyword">const</span> std::string&amp; name ) <span class="keyword">const</span>; 
<a name="l00100"></a>00100     };
<a name="l00101"></a>00101   }
<a name="l00102"></a>00102 }
<a name="l00103"></a>00103 
<a name="l00105"></a><a class="code" href="XMLNode_8hpp.html#a1c62b36a465bdee9c8d53e941c148027">00105</a> <span class="keyword">inline</span> std::string <a class="code" href="XMLNode_8hpp.html#a1c62b36a465bdee9c8d53e941c148027" title="Convert an INT64 to a string.">i64_to_string</a>( INT64 value ) {
<a name="l00106"></a>00106   std::stringstream number;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   <span class="keywordflow">if</span>( value &gt; 1000000000 ) {
<a name="l00109"></a>00109     number &lt;&lt; (value/1000000000) &lt;&lt; std::setw(9) &lt;&lt; std::setfill(<span class="charliteral">&apos;0&apos;</span>) &lt;&lt; (value%1000000000);
<a name="l00110"></a>00110   } <span class="keywordflow">else</span> {
<a name="l00111"></a>00111     number &lt;&lt; value;
<a name="l00112"></a>00112   }
<a name="l00113"></a>00113 
<a name="l00114"></a>00114   <span class="keywordflow">return</span> number.str();
<a name="l00115"></a>00115 }
<a name="l00116"></a>00116 
<a name="l00118"></a><a class="code" href="XMLNode_8hpp.html#a7483e08978ecfc16c84c6aa80df8fb67">00118</a> <span class="keyword">inline</span> INT64 <a class="code" href="XMLNode_8hpp.html#a7483e08978ecfc16c84c6aa80df8fb67" title="Convert a string to an INT64.">string_to_i64</a>( <span class="keyword">const</span> std::string&amp; str ) {
<a name="l00119"></a>00119   INT64 result = 0;
<a name="l00120"></a>00120   INT64 negative = 1;
<a name="l00121"></a>00121   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;
<a name="l00122"></a>00122 
<a name="l00123"></a>00123   <span class="keywordflow">if</span>( str.length() &gt; 0 &amp;&amp; str[0] == <span class="charliteral">&apos;-&apos;</span> ) {
<a name="l00124"></a>00124     negative = -1;
<a name="l00125"></a>00125     i = 1;
<a name="l00126"></a>00126   }
<a name="l00127"></a>00127 
<a name="l00128"></a>00128   <span class="keywordflow">for</span>( ; i&lt;str.length(); i++ ) {
<a name="l00129"></a>00129     result = result * 10 + (str[i] - <span class="charliteral">&apos;0&apos;</span>);
<a name="l00130"></a>00130   }
<a name="l00131"></a>00131 
<a name="l00132"></a>00132   <span class="keywordflow">return</span> result * negative;
<a name="l00133"></a>00133 }
<a name="l00134"></a>00134 
<a name="l00136"></a><a class="code" href="XMLNode_8hpp.html#a85380a8d97c6de79cfabfad863d5f5ff">00136</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="XMLNode_8hpp.html#a85380a8d97c6de79cfabfad863d5f5ff" title="Convert a string to an int.">string_to_int</a>( <span class="keyword">const</span> std::string&amp; str ) {
<a name="l00137"></a>00137   <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) <a class="code" href="XMLNode_8hpp.html#a7483e08978ecfc16c84c6aa80df8fb67" title="Convert a string to an INT64.">string_to_i64</a>( str );
<a name="l00138"></a>00138 }
<a name="l00139"></a>00139 
<a name="l00144"></a><a class="code" href="XMLNode_8hpp.html#a7f70eab251696c2fde274df35d414a80">00144</a> <span class="keyword">inline</span> std::string <a class="code" href="XMLNode_8hpp.html#a7f70eab251696c2fde274df35d414a80">base64_encode</a>( <span class="keyword">const</span> <span class="keywordtype">void</span>* <a class="code" href="TextParser_8cpp.html#a171692544b8e065853e387755849a433">input</a>, <span class="keywordtype">int</span> length ) {
<a name="l00145"></a>00145   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup[] = {
<a name="l00146"></a>00146     <span class="charliteral">&apos;A&apos;</span>, <span class="charliteral">&apos;B&apos;</span>, <span class="charliteral">&apos;C&apos;</span>, <span class="charliteral">&apos;D&apos;</span>, <span class="charliteral">&apos;E&apos;</span>, <span class="charliteral">&apos;F&apos;</span>, <span class="charliteral">&apos;G&apos;</span>, <span class="charliteral">&apos;H&apos;</span>, <span class="charliteral">&apos;I&apos;</span>, <span class="charliteral">&apos;J&apos;</span>, <span class="charliteral">&apos;K&apos;</span>, <span class="charliteral">&apos;L&apos;</span>, <span class="charliteral">&apos;M&apos;</span>,
<a name="l00147"></a>00147     <span class="charliteral">&apos;N&apos;</span>, <span class="charliteral">&apos;O&apos;</span>, <span class="charliteral">&apos;P&apos;</span>, <span class="charliteral">&apos;Q&apos;</span>, <span class="charliteral">&apos;R&apos;</span>, <span class="charliteral">&apos;S&apos;</span>, <span class="charliteral">&apos;T&apos;</span>, <span class="charliteral">&apos;U&apos;</span>, <span class="charliteral">&apos;V&apos;</span>, <span class="charliteral">&apos;W&apos;</span>, <span class="charliteral">&apos;X&apos;</span>, <span class="charliteral">&apos;Y&apos;</span>, <span class="charliteral">&apos;Z&apos;</span>, 
<a name="l00148"></a>00148     <span class="charliteral">&apos;a&apos;</span>, <span class="charliteral">&apos;b&apos;</span>, <span class="charliteral">&apos;c&apos;</span>, <span class="charliteral">&apos;d&apos;</span>, <span class="charliteral">&apos;e&apos;</span>, <span class="charliteral">&apos;f&apos;</span>, <span class="charliteral">&apos;g&apos;</span>, <span class="charliteral">&apos;h&apos;</span>, <span class="charliteral">&apos;i&apos;</span>, <span class="charliteral">&apos;j&apos;</span>, <span class="charliteral">&apos;k&apos;</span>, <span class="charliteral">&apos;l&apos;</span>, <span class="charliteral">&apos;m&apos;</span>,
<a name="l00149"></a>00149     <span class="charliteral">&apos;n&apos;</span>, <span class="charliteral">&apos;o&apos;</span>, <span class="charliteral">&apos;p&apos;</span>, <span class="charliteral">&apos;q&apos;</span>, <span class="charliteral">&apos;r&apos;</span>, <span class="charliteral">&apos;s&apos;</span>, <span class="charliteral">&apos;t&apos;</span>, <span class="charliteral">&apos;u&apos;</span>, <span class="charliteral">&apos;v&apos;</span>, <span class="charliteral">&apos;w&apos;</span>, <span class="charliteral">&apos;x&apos;</span>, <span class="charliteral">&apos;y&apos;</span>, <span class="charliteral">&apos;z&apos;</span>, 
<a name="l00150"></a>00150     <span class="charliteral">&apos;0&apos;</span>, <span class="charliteral">&apos;1&apos;</span>, <span class="charliteral">&apos;2&apos;</span>, <span class="charliteral">&apos;3&apos;</span>, <span class="charliteral">&apos;4&apos;</span>, <span class="charliteral">&apos;5&apos;</span>, <span class="charliteral">&apos;6&apos;</span>, <span class="charliteral">&apos;7&apos;</span>, <span class="charliteral">&apos;8&apos;</span>, <span class="charliteral">&apos;9&apos;</span>, <span class="charliteral">&apos;+&apos;</span>, <span class="charliteral">&apos;/&apos;</span>
<a name="l00151"></a>00151   };
<a name="l00152"></a>00152 
<a name="l00153"></a>00153   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* in = (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*) input;
<a name="l00154"></a>00154   std::string result;
<a name="l00155"></a>00155   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value;
<a name="l00156"></a>00156   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mainLength;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158   <span class="comment">// mainlength is the total length of contiguous 3-byte chunks</span>
<a name="l00159"></a>00159   <span class="keywordflow">if</span>( length%3 ) {
<a name="l00160"></a>00160     mainLength = length - length%3;
<a name="l00161"></a>00161   } <span class="keywordflow">else</span> {
<a name="l00162"></a>00162     mainLength = length;
<a name="l00163"></a>00163   }
<a name="l00164"></a>00164 
<a name="l00165"></a>00165   <span class="comment">// reserve enough string space to hold the result</span>
<a name="l00166"></a>00166   result.reserve( (length/2+1)*3 );
<a name="l00167"></a>00167 
<a name="l00168"></a>00168   <span class="comment">// main loop encodes each group of 3 8-bit chars as</span>
<a name="l00169"></a>00169   <span class="comment">// 4 6-bit chars</span>
<a name="l00170"></a>00170   <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;mainLength; i+=3 ) {
<a name="l00171"></a>00171     value = (in[i+0] &amp; 0xff) &lt;&lt; 16 |
<a name="l00172"></a>00172       (in[i+1] &amp; 0xff) &lt;&lt;  8 |
<a name="l00173"></a>00173       (in[i+2] &amp; 0xff);
<a name="l00174"></a>00174 
<a name="l00175"></a>00175     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fourth = lookup[value &amp; 0x3f];
<a name="l00176"></a>00176     value &gt;&gt;= 6;
<a name="l00177"></a>00177     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> third = lookup[value &amp; 0x3f];
<a name="l00178"></a>00178     value &gt;&gt;= 6;
<a name="l00179"></a>00179     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> second = lookup[value &amp; 0x3f];
<a name="l00180"></a>00180     value &gt;&gt;= 6;
<a name="l00181"></a>00181     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> first = lookup[value &amp; 0x3f];
<a name="l00182"></a>00182 
<a name="l00183"></a>00183     result.push_back( first );
<a name="l00184"></a>00184     result.push_back( second );
<a name="l00185"></a>00185     result.push_back( third );
<a name="l00186"></a>00186     result.push_back( fourth );
<a name="l00187"></a>00187   }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189   <span class="keywordflow">if</span>( mainLength != length ) {
<a name="l00190"></a>00190     value = 0;
<a name="l00191"></a>00191     <span class="keywordtype">int</span> remaining = length - mainLength;
<a name="l00192"></a>00192 
<a name="l00193"></a>00193     {
<a name="l00194"></a>00194       <span class="comment">// build a value based on the characters we </span>
<a name="l00195"></a>00195       <span class="comment">// have left</span>
<a name="l00196"></a>00196       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> first = 0;
<a name="l00197"></a>00197       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> second = 0;
<a name="l00198"></a>00198       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> third = 0;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200       <span class="keywordflow">if</span>( remaining &gt;= 1 )
<a name="l00201"></a>00201         first = in[mainLength+0];
<a name="l00202"></a>00202       <span class="keywordflow">if</span>( remaining &gt;= 2 )
<a name="l00203"></a>00203         second = in[mainLength+1];
<a name="l00204"></a>00204       <span class="keywordflow">if</span>( remaining &gt;= 3 )
<a name="l00205"></a>00205         third = in[mainLength+2];
<a name="l00206"></a>00206 
<a name="l00207"></a>00207       value = first &lt;&lt; 16 |
<a name="l00208"></a>00208         second &lt;&lt; 8 |
<a name="l00209"></a>00209         third;
<a name="l00210"></a>00210     }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212     {
<a name="l00213"></a>00213       <span class="comment">// encode them</span>
<a name="l00214"></a>00214       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fourth = <span class="charliteral">&apos;=&apos;</span>;
<a name="l00215"></a>00215       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> third = <span class="charliteral">&apos;=&apos;</span>;
<a name="l00216"></a>00216       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> second = <span class="charliteral">&apos;=&apos;</span>;
<a name="l00217"></a>00217       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> first = <span class="charliteral">&apos;=&apos;</span>;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219       <span class="keywordflow">if</span>( remaining &gt;= 3 )
<a name="l00220"></a>00220         fourth = lookup[value &amp; 0x3f];
<a name="l00221"></a>00221       value &gt;&gt;= 6;
<a name="l00222"></a>00222       <span class="keywordflow">if</span>( remaining &gt;= 2 )
<a name="l00223"></a>00223         third = lookup[value &amp; 0x3f];
<a name="l00224"></a>00224       value &gt;&gt;= 6;
<a name="l00225"></a>00225       <span class="keywordflow">if</span>( remaining &gt;= 1 )
<a name="l00226"></a>00226         second = lookup[value &amp; 0x3f];
<a name="l00227"></a>00227       value &gt;&gt;= 6;
<a name="l00228"></a>00228       first = lookup[value &amp; 0x3f];
<a name="l00229"></a>00229 
<a name="l00230"></a>00230       result.push_back( first );
<a name="l00231"></a>00231       result.push_back( second );
<a name="l00232"></a>00232       result.push_back( third );
<a name="l00233"></a>00233       result.push_back( fourth );
<a name="l00234"></a>00234     }
<a name="l00235"></a>00235   }
<a name="l00236"></a>00236 
<a name="l00237"></a>00237   <span class="keywordflow">return</span> result;
<a name="l00238"></a>00238 }
<a name="l00239"></a>00239 
<a name="l00245"></a><a class="code" href="XMLNode_8hpp.html#a301b9ee141e956ae2620761912d9d6a7">00245</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="XMLNode_8hpp.html#a301b9ee141e956ae2620761912d9d6a7">base64_decode</a>( <span class="keywordtype">void</span>* output, <span class="keywordtype">int</span> outputLength, <span class="keyword">const</span> std::string&amp; <a class="code" href="TextParser_8cpp.html#a171692544b8e065853e387755849a433">input</a> ) {
<a name="l00246"></a>00246   assert( (input.size() % 4) == 0 );
<a name="l00247"></a>00247 
<a name="l00248"></a>00248   <span class="comment">// encoding table built with a python script to match the encoding proposed in rfc1521</span>
<a name="l00249"></a>00249   <span class="keyword">static</span> <span class="keywordtype">char</span> lookup[] = {
<a name="l00250"></a>00250     -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
<a name="l00251"></a>00251     -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
<a name="l00252"></a>00252     -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   62,   -1,   -1,   -1,   63,
<a name="l00253"></a>00253     52,   53,   54,   55,   56,   57,   58,   59,   60,   61,   -1,   -1,   -1,    0,   -1,   -1,
<a name="l00254"></a>00254     -1,    0,    1,    2,    3,    4,    5,    6,    7,    8,    9,   10,   11,   12,   13,   14,
<a name="l00255"></a>00255     15,   16,   17,   18,   19,   20,   21,   22,   23,   24,   25,   -1,   -1,   -1,   -1,   -1,
<a name="l00256"></a>00256     -1,   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,   36,   37,   38,   39,   40,
<a name="l00257"></a>00257     41,   42,   43,   44,   45,   46,   47,   48,   49,   50,   51,   -1,   -1,   -1,   -1,   -1,
<a name="l00258"></a>00258     -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
<a name="l00259"></a>00259     -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
<a name="l00260"></a>00260     -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
<a name="l00261"></a>00261     -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
<a name="l00262"></a>00262     -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
<a name="l00263"></a>00263     -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
<a name="l00264"></a>00264     -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
<a name="l00265"></a>00265     -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1
<a name="l00266"></a>00266   };
<a name="l00267"></a>00267 
<a name="l00268"></a>00268   <span class="keywordtype">char</span>* out = (<span class="keywordtype">char</span>*) output;
<a name="l00269"></a>00269   <span class="keywordtype">int</span> trueOutputLength = 0;
<a name="l00270"></a>00270 
<a name="l00271"></a>00271   <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i=0; i&lt;input.size(); i+=4 ) {
<a name="l00272"></a>00272     <span class="comment">// decode 4 byte chunks</span>
<a name="l00273"></a>00273     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> first = input[i];
<a name="l00274"></a>00274     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> second = input[i+1];
<a name="l00275"></a>00275     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> third = input[i+2];
<a name="l00276"></a>00276     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fourth = input[i+3];
<a name="l00277"></a>00277 
<a name="l00278"></a>00278     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> value;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280     value = lookup[first] &lt;&lt; 18 |
<a name="l00281"></a>00281       lookup[second] &lt;&lt; 12 |
<a name="l00282"></a>00282       lookup[third] &lt;&lt; 6 |
<a name="l00283"></a>00283       lookup[fourth];
<a name="l00284"></a>00284 
<a name="l00285"></a>00285     <span class="keywordflow">if</span>( fourth == <span class="charliteral">&apos;=&apos;</span> ) {
<a name="l00286"></a>00286       <span class="comment">// this chunk ends in padding, so handle it in a special way</span>
<a name="l00287"></a>00287       <span class="keywordflow">if</span>( third == <span class="charliteral">&apos;=&apos;</span> ) {
<a name="l00288"></a>00288         <span class="comment">// only one additional byte</span>
<a name="l00289"></a>00289         out[trueOutputLength]   = (value &gt;&gt; 16) &amp; 0xff;
<a name="l00290"></a>00290         trueOutputLength++;
<a name="l00291"></a>00291       } <span class="keywordflow">else</span> {
<a name="l00292"></a>00292         <span class="comment">// two additional bytes</span>
<a name="l00293"></a>00293         out[trueOutputLength]   = (value &gt;&gt; 16) &amp; 0xff;
<a name="l00294"></a>00294         out[trueOutputLength+1] = (value &gt;&gt; 8) &amp; 0xff;
<a name="l00295"></a>00295         trueOutputLength+=2;
<a name="l00296"></a>00296       }
<a name="l00297"></a>00297     } <span class="keywordflow">else</span> {
<a name="l00298"></a>00298       out[trueOutputLength]   = (value &gt;&gt; 16) &amp; 0xff;
<a name="l00299"></a>00299       out[trueOutputLength+1] = (value &gt;&gt; 8) &amp; 0xff;
<a name="l00300"></a>00300       out[trueOutputLength+2] = (value) &amp; 0xff;
<a name="l00301"></a>00301 
<a name="l00302"></a>00302       trueOutputLength += 3;
<a name="l00303"></a>00303     }
<a name="l00304"></a>00304   }
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   assert( trueOutputLength &lt;= outputLength );
<a name="l00307"></a>00307   <span class="keywordflow">return</span> trueOutputLength;
<a name="l00308"></a>00308 }
<a name="l00309"></a>00309 
<a name="l00313"></a><a class="code" href="XMLNode_8hpp.html#af82a55617acc08d7b25d8977a1248fba">00313</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="XMLNode_8hpp.html#af82a55617acc08d7b25d8977a1248fba">base64_decode_string</a>( std::string&amp; out, <span class="keyword">const</span> std::string&amp; in ) {
<a name="l00314"></a>00314   <span class="keywordtype">char</span>* buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[in.size()+1];
<a name="l00315"></a>00315   <span class="keywordtype">size_t</span> outLength = <a class="code" href="XMLNode_8hpp.html#a301b9ee141e956ae2620761912d9d6a7">base64_decode</a>( buf, (<span class="keywordtype">int</span>)in.size()+5, in );
<a name="l00316"></a>00316   buf[outLength] = 0;
<a name="l00317"></a>00317   out = buf;
<a name="l00318"></a>00318   <span class="keyword">delete</span>[] buf;
<a name="l00319"></a>00319 }
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 <span class="preprocessor">#endif // MONITOR_XMLNODE_H</span>
<a name="l00322"></a>00322 <span class="preprocessor"></span>
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 17 Dec 2014 for Indri by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
